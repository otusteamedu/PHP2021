# PHP2021

## Домашняя работа №15

#### Тест кейсы для тестирования бэка страницы оплаты.

Будем считать, что на фронте никакой валидации вводимых данных не производится и вся проверка падает целиком на бэк.

1. Модульные тесты.

  1. Проверка JSON-объекта на валидность. Если результат равен null, возвращаем 400

  2. Проверяем заполненность поля card_number. Если поле пустое, тестируемый метод должен вернуть 400 с текстом ошибки

  3. Проверяем введенное значение в поле card_number выражением `^\d{16}$`. В случае наличия каки-либо символов кроме цифр, тестируемый метод должен вернуть 400 с текстом ошибки

  5. Проверяем заполненность поля card_holder. Если поле пустое, тестируемый метод должен вернуть 400 с текстом ошибки

  6. Проверяем введенное значение в поле card_holder. В случае наличия цифр или символов не относящихся к латинице (за исключением пробела и дефиса), тестируемый метод должен вернуть 400 с текстом ошибки

  7. Проверяем введенное значение в поле card_holder. Поле должно содержать один пробел в середине строки, иначе тестируемый метод должен вернуть 400 с текстом ошибки

  8. Проверяем заполненность поля card_expiration. Если поле пустое, тестируемый метод должен вернуть 400 с текстом ошибки

  9. Проверяем соответсиве значения поля card_expiration регулярному выражению ``/^\d{2}\/\d{2}$/``.
  При несоответствии, тестируемый метод должен вернуть 400 с текстом ошибки

  10. Разбиваем значение поля card_expiration по разделителю "/" и проверяем валидность введенного месяца и года. Для невалидных дат, тестируемый метод должен вернуть 400 с текстом ошибки

  11. Проверяем заполненность поля cvv. Если поле пустое, тестируемый метод должен вернуть 400 с текстом ошибки

  12. Проверяем соответсиве значения поля cvv регулярному выражению `^/\d{3}/$`.
  При несоответствии, тестируемый метод должен вернуть 400 с текстом ошибки

  13. Проверяем заполненность поля order_number. Если поле пустое, тестируемый метод должен вернуть 400 с текстом ошибки

  14. Проверяем количество символов в поле order_number. Если символов меньше 1 или более 16 тестируемый метод должен вернуть 400 с текстом ошибки

  15. Проверяем заполненность поля sum. Если поле пустое, тестируемый метод должен вернуть 400 с текстом ошибки

  16. Проверяем валидность данных в поле sum выражением `^\d+,\d{2}$`. При несоответствии, тестируемый метод должен вернуть 400 с текстом ошибки

2. Интеграционные тесты. У нас есть связки "Фронт-бэк", "Бэк-сервис А", "Бэк-репозиторий"

  1. Связка "Фронт-бэк". В задаче указано описывать сильно отличающееся поведение, поэтому часть тестов, которая касается валидации вышеуказанных полей JSON-объекта соединены в один пункт

    a. В случае незаполненности одного из полей бэк возвращает 400 с текстом ощибки. На фронте выделяется красной рамкой соответствующее поле и выводится текст ошибки "Заполните поле"

    b. В случае ошибки валидации полей бэк возвращает 400 с текстом ощибки. На фронте выделяется красной рамкой соответствующее поле и выводится текст ошибки "Указаны неверные данные" и соответствующая подсказка (например, Номер карты должен состоять из 16 цифр без пробелов)

    c. В случае ошибки валидации JSON-объекта или неправильного типа запроса (будем считать, что на бэк приходит POST запрос, в теле которого лежит JSON), бэк возвращает 400, фронт должен отобразить текст "Ошибка отправки формы, перезагрузите страницу"

  2. Связка "Бэк-сервис А". После валидации данных бэк передает платежному сервису необходимые для оплаты реквизиты

    a. Передаем заведомо неправильные данные в платежный сервис. Например, несоответствующие реальному номеру карты данные кода cvv или наоборот. Проверяем, что ответ сервиса содержит 403. Думаю одного такого теста будет достаточно, так как нас интересует именно то, как выглядит ответ на предоставленную некорректную информацию

    b. Передаем корректные данные в платежный сервис. Проверяем, что оплата прошла успешно и сервис ответил 200. Касательно затрат на тестирование могу отметить, что в рамках рабочего проекта enex.market приходилось тестировать платежную систему и, так как должны быть сгенерированы настоящие чеки для Налоговой службы,  на сайте некоторое время имелась специальная тестовая позиция, в виде отвертки стоимостью в 10 рублей.

  3. Связка "Бэк-репозиторий"

    a. Передаем в метод `SetOrderIsPaid` несуществующий номер заказа. В ответ ловим исключение "Номер заказа не найден"

    b. Передаем в метод `SetOrderIsPaid` корректные номер заказа и сумму, проверяем, что вернулось true

    c. Передаем в метод `setOrderIsPaid` существующий номер заказа, но некорректную сумму. Ловим исключение "Неверная сумма для заказа $orderNumber"

3. Системные тесты

  1. При успешной валидации полей, но непрошедшей оплате, сервис возвращает бэку 403, бэк возвращает 403 и на фронте должно отобразиться сообщение о том что "Оплата не удалась, проверьте данные карты".

  2. При успешной валидации полей и проведении оплаты, сервис возвращает 200 бэку, бэк записывает данные в репозиторий и возвращает 200 фронту. Проверяем что фронт выводит информацию об успешной оплате. Так же проверяем статус и  наличие указанного заказа в Репозитории, который должен измениться на `Оплачен`. На мой взгляд тут есть нюанс, так как метод `setOrderIsPaid` не гарантирует возврат true при успешной оплате через платежный сервис, из-за чего деньги с карты будут списаны, но в Репозитории заказ останется со статусом `Не оплачен` или вообще не окажется такого заказа. Скорее всего в этой ситуации перед использованием API платежного сервиса будет вызван метод checkOrderSum илии просто checkOrder. Если сумма не будет соответствовать, то фронту отправится 400 и текст ошибки "Некорректная сумма". В случае наличия номера заказа и соответствия оплачиваемой суммы, будут вызваны методы платежного сервиса и уже после получения ответа 200 вызван метод `setOrderIsPaid`, в котором скорее всего будет только один аргумент в виде номера заказа.
